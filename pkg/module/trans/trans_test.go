package trans

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"sort"
	"strconv"
	"strings"
	"testing"
)

func Test_GeneateFunc(t *testing.T) {
	if os.Getenv("FLUTENAS_ENABLE_I18N_TESTS") != "1" {
		t.Skip("i18n tests disabled")
	}
	keys := make([]string, 0)
	for id := range translation {
		keys = append(keys, id)
	}
	sort.SliceStable(keys, func(i, j int) bool {
		return keys[i] < keys[j]
	})

	f, err := os.OpenFile("zz_generated.go", os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		t.Fatalf("failed to open file: %s", err)
	}
	f.WriteString("package trans\n\n")
	f.WriteString("// Code generated by Test_GeneateFunc in trans_test.go. DO NOT EDIT.\n\n")
	for _, id := range keys {

		comment := GetTransMap(id).Get(LocaleChinese)
		scan := bufio.NewScanner(strings.NewReader(comment))
		comStr := ""
		for scan.Scan() {
			l := scan.Text()
			comStr = fmt.Sprintf("%s %s\n", comStr, l)
		}
		// 检查翻译在其他语言中是否存在
		for _, l := range Langs {
			if l == LocaleChinese {
				continue
			}
			if GetTransMap(id).Get(l) == "" {
				t.Errorf("%s: %s translation not found in %s language", id, comment, l)
			}
		}

		f.WriteString(fmt.Sprintf(`// %s :
/* 
%s
 */
var %s = func() Trans { return GetTransMap("%s") }
`, id, strings.TrimSuffix(comStr, "\n"), id, id,
		))
	}
}

func Test_AutoTranslate(t *testing.T) {
	if os.Getenv("FLUTENAS_ENABLE_I18N_TESTS") != "1" {
		t.Skip("i18n tests disabled")
	}
	// 指定需要翻译的范围，根据实际需求修改, 不建议翻译多行内容
	// WRF0000-3 代表 WRF0000,WRF0001,WRF0002,WRF0003
	idRange := "WRF0000-3,WRF0004,WRF0005"
	// idRange := "WRF0005,WRF0014"

	var proxyURL *url.URL
	// 请求google翻译是否使用代理, 根据实际环境修改，不需要则注释
	proxyAddr := "http://127.0.0.1:7890"
	proxyURL, err := url.ParseRequestURI(proxyAddr)
	if err != nil {
		t.Errorf("http proxy address invalid")
		return
	}

	arrs := strings.Split(idRange, ",")
	for _, item := range arrs {
		if strings.Contains(item, "-") {
			rs := strings.SplitN(item, "-", 2)
			product := rs[0][0 : len(rs[0])-4]
			startS := rs[0][len(rs[0])-4 : len(rs[0])]
			endS := rs[1]
			start, _ := strconv.Atoi(startS)
			end, _ := strconv.Atoi(endS)
			for i := start; i <= end; i++ {
				id := fmt.Sprintf("%s%04d", product, i)
				if err = translateLangs(id, proxyURL); err != nil {
					t.Errorf("translate %s error: %v", id, err)
				}
			}
		} else {
			if err = translateLangs(item, proxyURL); err != nil {
				t.Errorf("translate %s error: %v", item, err)
			}
		}
	}

	// 重新生成txt文件
	for _, lang := range Langs {
		// if lang == LocaleChinese {
		// 	continue
		// }
		f, err := os.OpenFile(fmt.Sprintf("i18n/%s.txt", lang), os.O_CREATE|os.O_RDWR, 0644)
		if err != nil {
			panic(err)
		}

		lines := []string{}
		for id, trans := range translation {
			if trans[lang] == "" {
				continue
			}
			line := fmt.Sprintf("%s:%s", id, trans[lang])

			lines = append(lines, line)

		}
		// sort
		sort.SliceStable(lines, func(i, j int) bool {
			return lines[i] < lines[j]
		})
		for _, line := range lines {
			if strings.Contains(line, "\n") {
				arr := strings.SplitN(line, ":", 2)
				if len(arr) != 2 {
					t.Errorf("%s translation in %s is error", line, lang)
					continue
				}
				id := arr[0]
				content := arr[1]
				for _, c := range strings.Split(content, "\n") {
					f.WriteString(fmt.Sprintf("%s:%s\n", id, c))
				}
			} else {
				f.WriteString(line + "\n")
			}
		}
	}
}

func translateLangs(id string, proxyURL *url.URL) error {
	target := GetTransMap(id)
	source := target.Get(LocaleChinese)
	if source == "" {
		return fmt.Errorf("%s translation not found in zh-CN.txt", id)
	}
	for _, lang := range Langs {
		if lang == LocaleChinese {
			continue
		}
		result, err := googleTranslate(source, lang, proxyURL)
		if err != nil {
			return err
		}
		fmt.Printf("AutoTranslate source: %s to target: %s, result: %s\n", source, lang, result)

		translation[id][lang] = result

	}
	return nil
}

func googleTranslate(source string, locale Locale, proxyURL *url.URL) (string, error) {
	headers := map[string]string{
		"Accept":       "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
		"Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
		"User-Agent":   "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.66 Safari/537.36",
	}
	// 启动一个http请求
	client := http.Client{}
	if proxyURL != nil {
		client.Transport = &http.Transport{
			Proxy:             http.ProxyURL(proxyURL),
			DisableKeepAlives: true,
		}
	}

	target := "en"
	switch locale {
	case LocaleChinese:
		target = "zh-CN"
	case LocaleEnglish:
		target = "en"
	case LocaleFrench:
		target = "fr"
	case LocaleSpanish:
		target = "es"
	case LocaleArabic:
		target = "ar"
	case LocaleRussian:
		target = "ru"
	case LocalePortuguese:
		target = "pt"
	}
	reqUrl := fmt.Sprintf(`https://translate.googleapis.com/translate_a/single?client=gtx&dt=t&sl=zh-CN&tl=%s&q=%s`, target, url.PathEscape(source))
	req, _ := http.NewRequest(http.MethodPost, reqUrl, nil)
	for k, v := range headers {
		req.Header.Set(k, v)
	}

	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	//读取 body
	bs, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	// fmt.Println(string(bs))
	str := ""
	// 解析返回内容
	result := []interface{}{}
	err = json.Unmarshal(bs, &result)
	if err != nil {
		return "", err
	}
	if len(result) > 0 {
		a2, ok := result[0].([]interface{})
		if !ok || len(a2) == 0 {
			return "", fmt.Errorf("translate error")
		}
		for _, v := range a2 {
			line, ok := v.([]interface{})
			if !ok || len(line) == 0 {
				return "", fmt.Errorf("translate error")
			}

			str = line[0].(string)
		}
	}

	return str, nil
}

func TestTranslationFormat(t *testing.T) {
	if os.Getenv("FLUTENAS_ENABLE_I18N_TESTS") != "1" {
		t.Skip("i18n tests disabled")
	}
	tests := []struct {
		id   string
		arg  interface{}
		want string
	}{
		{
			id:   "ISP0035",
			arg:  20.2342,
			want: "20.23% used",
		},
	}
	for _, tt := range tests {
		SetDefaultLocale(string(LocaleEnglish))
		t.Run(tt.id, func(t *testing.T) {
			if got := GetTransMap(tt.id).Sprintf(LocaleEnglish, tt.arg); got != tt.want {
				t.Errorf("TranslationRaw() = %v, want %v", got, tt.want)
			}
		})
	}
}
